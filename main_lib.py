#	File Created:
#	Author: Jack Connor <jconnor@baaqmd.gov>

import osmnx as ox
import networkx as nx
import pandas as pd
import matplotlib.pyplot as plt
import gpxpy
from collections import Counter

def circuit_path_string_to_int(circuit_rpp):
    """
    Converts nodes in path lists from strings to integers
    Args:
        circuit_rpp (list): rpp circuit generated by postman_problems.solver.rpp
    Returns:
        circuit_rpp (list): modified circuit
    """
    for e in circuit_rpp:
        if type(e[3]['path']) == str:
            exec('e[3]["path"]=' + e[3]["path"])
    return(circuit_rpp)

def create_req_and_opt_graph(req_comp_g_contracted, complete_g, circuit_rpp, GranularConnector_EdgeList):
    """
    Creates a graph with required and optional edges delineated for visualization
    Args:
        req_comp_g_contracted (NetworkX MultiDiGraph): required component graph containing contracted edges
            generated by initialize_rpp.InnerAndOuterToEdgeListFile
        complete_g (NetworkX MultiDiGraph): complete street network graph
            generated by initialize_rpp.InnerAndOuterToEdgeListFile
        circuit_rpp (list): rpp circuit generated by postman_problems.solver.rpp and
            edited by circuit_path_string_to_int
    Returns:
        final_graph (NetworkX DiGraph): graph of route with optional and required edges delineated
        print statements with required and optional edge breakdown
    """
    final_graph = req_comp_g_contracted.copy()
    unexpanded_edges = 0
    unexpanded_edges_list = []
    granular_connector_edges = 0
    granular_connector_edges_list = []
    granular_req_edges = 0
    granular_req_edges_list = []
    optional_edges = 0
    optional_edges_list = []
    for e in circuit_rpp:
        if [e[0], e[1]] not in unexpanded_edges_list:
            unexpanded_edges+=1
            unexpanded_edges_list+=[[e[0], e[1]]]
        # add granular optional edges to final_graph
        path = e[3]['path']
        for pair in list(zip(path[:-1], path[1:])):
            if (req_comp_g_contracted.has_edge(pair[0], pair[1])):
                edge = req_comp_g_contracted[pair[0]][pair[1]][0]
                if [pair[0], pair[1]] in GranularConnector_EdgeList:
                    final_graph[pair[0]][pair[1]][0]['granular_type'] = 'req street and connector'
                    if [pair[0], pair[1]] not in granular_connector_edges_list:
                        granular_connector_edges+=1
                        granular_connector_edges_list+=[[pair[0], pair[1]]]
                    elif 1 in req_comp_g_contracted[pair[0]][pair[1]]:
                            granular_connector_edges+=1
                else:
                    if [pair[0], pair[1]] not in granular_req_edges_list:
                        final_graph[pair[0]][pair[1]][0]['granular_type'] = 'req street'
                        granular_req_edges+=1
                        granular_req_edges_list+=[[pair[0], pair[1]]]
            else:
                if [pair[0], pair[1]] in GranularConnector_EdgeList:
                    if [pair[0], pair[1]] not in granular_connector_edges_list:
                        final_graph.add_edge(pair[0], pair[1], granular=True, granular_type='connector')
                        granular_connector_edges+=1
                        granular_connector_edges_list+=[[pair[0], pair[1]]]
                elif [pair[0], pair[1]] not in optional_edges_list:
                    final_graph.add_edge(pair[0], pair[1], granular=True, granular_type='optional')
                    optional_edges+=1
                    optional_edges_list+=[[pair[0], pair[1]]]
                else:
                    print(pair)
        for n in path:
            final_graph.add_node(n, y=complete_g.nodes[n]['y'], x=complete_g.nodes[n]['x'])
    print('Edges in Circuit')
    print('\tTotal Unexpanded Edges: {}'.format(unexpanded_edges))
    print('\tTotal Edges (All Contracted Edges Granularized): {}'.format(granular_connector_edges+granular_req_edges+optional_edges))
    print('\t\tGranular Connector Edges: {}'.format(granular_connector_edges))
    print('\t\tGranular Required Edges: {}'.format(granular_req_edges))
    print('\t\tGranular Optional Edges: {}'.format(optional_edges))
    return final_graph

def create_number_of_passes_graph(circuit_rpp, complete_g):
    """
    labels each edge with number of passes for visualization
    Args:
        circuit_rpp (list): rpp circuit generated by postman_problems.solver.rpp and
            edited by circuit_path_string_to_int
         complete_g (NetworkX MultiDiGraph): complete street network graph
            generated by initialize_rpp.InnerAndOuterToEdgeListFile
    Returns:
        grppviz(NetworkX Graph): route graph with number of pass attribute added to each edge
    """
    color_seq = [None, 'black', 'magenta', 'orange', 'yellow']
    grppviz = nx.Graph()
    for e in circuit_rpp:
        for n1, n2 in zip(e[3]['path'][:-1], e[3]['path'][1:]):
            if grppviz.has_edge(n1, n2):
                grppviz[n1][n2]['cnt'] += 1
                if grppviz[n1][n2]['cnt'] < 5:
                    grppviz[n1][n2]['linewidth'] += 2
            else:                
                grppviz.add_edge(n1, n2, linewidth=2.5)
                grppviz[n1][n2]['cnt'] = 1
                grppviz.add_node(n1, y=complete_g.nodes[n1]['y'], x=complete_g.nodes[n1]['x'])
                grppviz.add_node(n2, y=complete_g.nodes[n2]['y'], x=complete_g.nodes[n2]['x']) 
    for e in grppviz.edges(data=True):
        if e[2]['cnt'] < 5:
            e[2]['color_cnt'] = color_seq[e[2]['cnt']]
        else:
            e[2]['color_cnt'] = color_seq[4]
    return grppviz

def circuit_parser(circuit_rpp, complete_g, print_file, print_directory):
    """
    Creates dataframe of lat/lon coordinates corresponding to each node in the route
    Prints the dataframe to a csv file
    Args:
        circuit_rpp (list): rpp circuit generated by postman_problems.solver.rpp and
            edited by circuit_path_string_to_int
        complete_g (NetworkX MultiDiGraph): complete street network graph
            generated by initialize_rpp.InnerAndOuterToEdgeListFile
            lat/lon data contained her
        print_file (str): filename to print to
        print_directory (str): directory name for print_file
    Returns:
        rppdf (Pandas DataFrame): table of lat/lon coordinates of nodes in order they appear in route
        prints table to csv file
       
    """
    rpplist = []
    for ee in circuit_rpp:
        path = ee[3]['path'].copy()
        if ee == circuit_rpp[0]:
            if path[-1] in circuit_rpp[1][3]['path']:
                path = path
            else:
                path.reverse()
                path = path
            for n in path:
                rpplist.append({
                    'node' : n,
                    'lat' : complete_g.nodes[n]['y'],
                    'lon' : complete_g.nodes[n]['x']
                })
        else:
            if path[0] == rpplist[-1]['node']:
                path = path[1:]
            elif path[-1] == rpplist[-1]['node']:
                path.reverse()
                path = path[1:]
            for n in path:
                rpplist.append({
                    'node' : n,
                    'lat' : complete_g.nodes[n]['y'],
                    'lon' : complete_g.nodes[n]['x']
                })
    rppdf = pd.DataFrame(rpplist)
    rppdf.to_csv(print_directory + print_file + '.csv', index=False)
    print('\nRoute written to .csv as ' + print_directory + print_file + '.csv')
    return rppdf

def gpx_writer(rppdf, print_file, print_directory):
    """
    Writes route dataframe into gpx file
    Args:
        rppdf (Pandas DataFrame): route dataframe generated by circuit_parser
        print_file (str): filename to print to
        print_directory (str): directory name for print_file
    Returns:
        gpx file containing route
    """
    gpx = gpxpy.gpx.GPX()
    gpx_track = gpxpy.gpx.GPXTrack()
    gpx.tracks.append(gpx_track)
    gpx_segment = gpxpy.gpx.GPXTrackSegment()
    gpx_track.segments.append(gpx_segment)

    for index, row in rppdf.iterrows():
        gpx_segment.points.append(gpxpy.gpx.GPXTrackPoint(row['lat'], row['lon']))
    f = open(print_directory + print_file + '.gpx', 'w+')
    print(gpx.to_xml(), file = f)
    f.close()
    print('Route written to .gpx as ' + print_directory + print_file + '.gpx')

def plot_req_and_opt_graph(req_and_opt_graph):
    """
    Plots all edges of route and colors by required and optional edges
    Args:
        req_and_opt_graph (NetworkX Graph): graph of required and optional route edges
        generated by create_req_and_opt_graph
    Returns:
        plot of req_and_opt_graph
    """
    fig, ax = plt.subplots()

    pos = {k: (req_and_opt_graph.nodes[k].get('x'), req_and_opt_graph.nodes[k].get('y')) for k in req_and_opt_graph.nodes()}    

    el_opt = [e for e in req_and_opt_graph.edges(data=True) if e[2].get('granular_type') == 'optional'] 
    nx.draw_networkx_edges(req_and_opt_graph, pos, edgelist=el_opt, ax = ax, width=6.0, edge_color='blue', alpha=1.0)

    el_rd = [e for e in req_and_opt_graph.edges(data=True) if e[2].get('granular_type') in ['req street', 'connector', 'req street and connector']]
    nx.draw_networkx_edges(req_and_opt_graph, pos, edgelist=el_rd, ax = ax, width=3.0, edge_color='black', alpha=0.8)

    ax.set_xlim(left = min([pos[node][0] for node in req_and_opt_graph.nodes()]), right = max([pos[node][0] for node in req_and_opt_graph.nodes()]))
    ax.set_ylim(bottom = min([pos[node][1] for node in req_and_opt_graph.nodes()]), top = max([pos[node][1] for node in req_and_opt_graph.nodes()]))

    print('\nRequired and Optional Edge Graph\nRequired Edges in Black\nOptional Edges in Blue')

    plt.show()

def plot_number_of_passes_graph(grppviz):
    """
    Plots route graph with color and thickness of edge determined by number of passes
    Args:
        grppviz (NetworkX Graph): route graph with number of pass data
        generated by create_number_of_passes_graph
    Returns:
        Plot of route with number of passes depicted by color and edgewidth
    """
    fig, ax = plt.subplots()

    pos = {k: (grppviz.nodes[k]['x'], grppviz.nodes[k]['y']) for k in grppviz.nodes()}    

    e_width = [e[2]['linewidth'] for e in grppviz.edges(data=True)]
    e_color = [e[2]['color_cnt'] for e in grppviz.edges(data=True)]

    nx.draw_networkx_edges(grppviz, pos, ax = ax, width=e_width, edge_color=e_color, alpha=0.7)

    ax.set_xlim(left = min([pos[node][0] for node in grppviz.nodes()]), right = max([pos[node][0] for node in grppviz.nodes()]))
    ax.set_ylim(bottom = min([pos[node][1] for node in grppviz.nodes()]), top = max([pos[node][1] for node in grppviz.nodes()]))

    print('\nNumber of Passes Graph\nBlack\t1 Pass\nMagenta\t2 Passes\nOrange\t3 Passes\nYellow\t4 or More Passes')
    plt.show()

